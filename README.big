treeprng alpha-test version README

Repeatable virtual trees of pseudorandom number generators.

Copyright (c) 2013 Steve Witham.  All rights reserved.  
treeprng is available under a BSD license, whose full text is at
    https://github.com/switham/treeprng/blob/master/LICENSE

REQUEST FOR FEEDBACK

The usage directions are in treeprng.py.  I've got chunks of text to 
make a web page out of.  Here I want to describe the idea quickly to
get feedback about 
  o  The need for virtural-tree-shaped pseudorandom number sources.
  o  Issues of doing it "randomly," in the sense that the numbers are as
     reliably random-like as we can expect.  Similiarities to & differences 
     from a crytography or security problem.
  o  Issues of doing it useably, hopefully "naturally;" how to reduce 
     the chance of quietly shooting the user in the foot.
  o  The issue of efficiency, whether it's even possible to do better.

It seems to me this is a general problem that needs a "right" solution.  Casual solutions would lead to either hard-to-diagnose bugs, hard-to-maintain code, or quality degradation that would be hard to even detect.  As with PRNGs in general, each programmer shouldn't have to reinvent the right algorithm, API, and practice, because the trickiness is easy to underestimate.  So,

  o  Is there already good literature or established practice?
  o  How does the present solution fare?

THE NEED

The most obvious application is in games with large, procedurally-generated virtual worlds.  The user must visit a part of the world, see lots of detail, visit other places, then revisit previously-seen parts and have them be the same (modulo intentional changes).  It's handy to generate detail in a hierarchy from coarse to fine.  One doesn't want to store all the details of visited places or scenes.  Any changes should hang on the framework of unchanged structure and details, which should come back out of the random number generator when you ask for them again.  The "random" detail should not accidentally repeat itself in different parts of the world.

That'll be my main example, but here are some uses that put different demands on a similar service: Software testing that can be repeatable.  I want to add or subtract individual test cases without invalidating previous results, but also without having to regenerate data for tests I'm not running.  Monte Carlo or other simulations exploring (say) structured data or spaces with contingent features.  Randomized algorithms.  Parallel tree or graph searches.  Genetic algorithms and genetic programming.  Dynamic programming with memoizing caches.  Simulations carried out in a massively-parallel way, where workers shouldn't repeat the same cases accidentally, but you might want to replay or resume tasks in different or changed computing environments.  "Here's a random case where f(case) > y."  Procedurally-generated art and music.  I want to examine how that song from last year was composed in detail, and tweak it.

BASIC APPROACH HERE

The programmer breaks the problem down hierarchically, into a tree, structured by the class hierarchy and data structures, which naturally follow the problem structure (of course!).  Classes shouldn't have to know about each other's use of namespace, naming or allocation issues shouldn't require careful planning by the programmer.  The root of the tree is the seed, one takes care to make it truly unique.  At each point where there are a variety of features or options, give them all mnemonic names.  For the most part each node should have a namespace rather than a sequential list, but number-indexed spaces need to be accomodated.  The point is both random access and software changeability.  I may decide that footwear has laces but not brand names.  My code and existing state shouldn't break.

Arbitrarily-deep, arbitrarily wide, arbitrarily dense or sparse, arbitrarily-shaped trees should be accomodated without penalties.  Fitting these to non-treelike problem spaces isn't automatic but shouldn't be made needlessly hard either.  One needs to temporarily hold onto nodes one has walked to, one needs the ability to let go and walk the same path again.  The space cost of holding a node should be constant.  The time cost of walking to a node should be O(the number of steps from the root or a node one is holding).

The TreePRNG class here does this: keys to steps down the tree are converted to canonical byte strings.  The strings are self-delimiting so that it's never possible for two different sequences of steps to convert to the same sequence of bytes.  As one steps down, the byte strings are absorbed into (fixed-size) cryptographic hash objects.  Sibling nodes are copies of the parent fed different next step byte strings.  When one finally wants random numbers, one hardens a node into a leaf by seeding a PRNG with the digest of the hash.

RANDOMNESS, why it's harder than PRNG.

The problem isn't just having a good PRNG.  The Python standard random.Random module uses the respected Mersenne Twister, with a period of 2**19937-1, but the method to set the seed uses the standard Python hash() function, which returns a (different) 32 or 64 bit number, depending on how Python is built... unless one always uses a long int as the seed.  That's a pitfall that can be boarded over.

The main additional internal problem is this: recursive algorithms, in particular generative algorithms feed the output of a function back into itself.  Feedback has a way of locating resonances, cycles and attractors.  Genetic algorithms have been known to evolve "solutions" that exploit flaws in both software and hardware rather than solve the intended problem.  If the state at a point in a tree can select a path through the tree, will it locate flaws in the method?

The method of hashing the path down the tree was picked as an alternative to 
    "SELF-SEEDING": Generating the seed for a subtree 
                    from the PRNG stream of the parent.

The problem is less than a cryptographic problem, but more like a crypto problem than the already-tricky good-PRNG problem.  We already want non-crypto PRNGs to produce numbers with good statistics looked at from a variety of points of view.  I want to avoid patterns generated by the combination of the PRNG and an unknown program using it.  I want to avoid "accidental cryptanalysis."

Self-seeding breaks the strength of a perfectly-random function in half by creating a cycle whose length is about the square root of the size of the domain of the function.  For 32-bit functions I've seen cycles of < 7000.

If there's a problem with (e.g.) the Mersenne twister (is there a good reference for why we know that non-crypto PRNGs are not strong?), would a crypto PRNG solve the problem?  Is seeding the PRNG with the hash of the path a bad practice? Are there obvious ways of using it that would be bad practices?  Also, suppose one wants to use a tree-PRNG in cryptography or cryptanalysis, how much stronger should it be?

USEABILITY

My main unease is the clash between the stateless tree and the stateful PRNG's at its leaves.  With the Python TreePRNG class, these two patterns aren't equivalent:
    r = node["foo"]
    x = r.random()
    y = r.random()
and
    x = node["foo"].random()
    y = node["foo"].random()

An alternative is to bite the bullet and make each node obey exactly one call to one of the Random methods.  So we have a static tree of random numbers.  The bullet is the cost of calculating a hash digest and seeding a PRNG for each number generated.  Is there a way to reduce that?  This essentially gives the problem of producing sequences to the programmer, who has to invent his own state (say a list index).  Does the first-value vs. next-value issue just reappear then?

Another problem is that Python's random.Random has many methods.  Random floats, ints, choices from lists, shuffles, floats in different distributions, etc.  Would a programmer be tempted to think that the following were independent?

    shoe_size = node.randrange(8,13)
    ...
    hair_color = node.choice["brown", "blond"]
as opposed to what should truly make them independent:
    shoe_size = node["shoe_size"].randrange(8,13)
    ...
    hair_color = node["hair_color"].choice["brown", "blond"]

Currently the TreePRNG has a strange polymorphism: it starts out pluripotent, but if you use it as an internal tree node, it hardens into an internal node, whereas if you ask it for a random number, it hardens into a PRNG.  The point was to avoid answering the following question: after a node has generating N random numbers, will a descendent with a given name be the same, or different, from a descendent of the same node before it had generated those numbers?  I find it easy to imagine that in different contexts I might assume that either was the obvious semantics.  Is my way of avoiding that confusion too confusing itself?  Is there a better alternative?

Are there any other subtle abuse-cases that come to mind?

EFFICIENCY

Since I don't "really" want crypto strength, is this method doing just way too much work?  Is there a much 


