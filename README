treeprng alpha-test version README

Repeatable virtual trees of pseudorandom number generators.

Copyright (c) 2013 Steve Witham.  All rights reserved.  
treeprng is available under a BSD license, whose full text is at
    https://github.com/switham/treeprng/blob/master/LICENSE

Steve Witham <treeprng@mac-guyver.com>

The treeprng.TreePRNG class creates nodes for "visiting" a virtually-
already-existing tree of nodes and random number generators, for use 
in virtual game worlds, software testing and Monte Carlo simulations,
distributed algorithms, and any application where you need parallel,
drill-downable sources of random numbers that can be repeated, 
revisited or resumed without needing to store the generated numbers.

There are use examples and instructions in the module and class
docstrings in treeprng.py.  

REQUEST FOR FEEDBACK on the wiki: https://github.com/switham/treeprng/wiki

treeprng is in alpha test, meaning I would like feedback about whether
it is even the right approach, in three senses:  1) is the technical 
method suitably pseudorandom?  2) Reasonably efficient?  3) are the
API and usage pattern I suggest in the docstrings a good model?

Please read the docstrings, read the technical blurb (immediately
below), perhaps try it out, and let me know how you think treprng
measures on those three scales.

0) (okay another) Do you see the goal I'm aiming at, do you agree it's
tricky enough to do right that it deserves a standard method?

1) PSEUDORANDOMNESS

node = TreePRNG(seed) creates the root node (or node visitor perhaps)
for an imaginary tree keyed by the seed.  From that (or any) node you 
can step down to a subnode with subnode = node[step_key], creating
another TreePRNG instance.  At any point where you want random 
numbers, you can use one of the Python random.Random methods.  If
you exit the program, come back the next day, start with the same seed, 
walk the same path and call the same Random method, you will get 
the same result.  The TreePRNG objects just remember *where* you are
in the tree (once in PRNG mode they remember PRNG state); the tree
and its PRNG streams are just functions of the access paths.  To put
it differently, it's a way of seeding a PRNG with an arbitrarily-long
path.

This is literally true: the seed and keys down a path are serialized
and processed through hashlib.sha1 to produce a 160-bit seed for Random's 
Mersenne Twister PRNG.

Each TreePRNG node contains a fixed-size unchanging state of SHA1.  
Whenever you move to a subnode, the state is copied and the copy 
is updated with the serialized step key.  Then the parent node object 
can be discarded and garbage-collected if not needed.

generative algorithms, problem-solving algorithms, Monte Carlo methods, 
and genetic algorithms can all feed back on themselves.  If they feed 
back through this module, and there are resonances, cycles,
or attractors in the combination, they may find attractors and get 
unrandom numbers from the module.  This looks like a harder problem
than just producing good pseudorandomness in a stream; the issue is
something like "accidental cryptanalysis."  I'm not sure how to
characterize the problem.  At this point I'm not looking for a PRNG
to resist deliberate cracking attempts, just to behave in a random-
like way in the face of feedback situations.  To me, the problem 
seems hard enough that it makes sense to use crypto components
that already solve the issues I see.  Is that smart?

As an example: an earlier approach of mine was to generate subtree
seeds out of the PRNG output from the parent node.  Even if
the parent were a huge random one-time pad, this would reduce its 
cycle time (taking any repeating step pattern down the tree)
to around a square root of what it was.  Right?

2) EFFICIENCY

Given the goal, is this method, which runs a hash digest to seed each
leaf of the tree, about as efficient as I can expect?  Will the time
cost encourage users to avoid using the tree in its intended random-
access way?

3) USABILITY

The main question is A) How sensible does the API seem to you?
There are three further concerns I have: B) Should the leaves only 
support a single call to Random rather than being streams?  In that
case the user would have to keep the index into any virtual stream
being used.  And also not forget that repeated calls will not 
produce different outputs.
C) is the behavior where the object starts out 
uncommitted but hardens into either an internal node or a PRNG
confusing?  D) Will the docstring use suggestions or the API itself 
lead people naturally into any bad practices?

In any case, thanks for your consideration.  I invite you to add
and feedback and discuss on the wiki page:
    https://github.com/switham/treeprng/wiki

I want you to write and edit there; to do that
   1) You need a github account (the free account is good):
      https://github.com/join

   2) Send me a note at (ahem) treeprng at mac-guyver dot com 
      and I'll make you a "collaborator".

A note by email is fine if you don't have time to wiki.

 --Steve,  Dec. 15, 2013